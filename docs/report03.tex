%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Intro to LaTeX and Template for Homework Assignments
%% Quantitative Methods in Political Science
%% University of Mannheim
%% Fall 2018
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% created by Marcel Neunhoeffer & Sebastian Sternberg


% This template and tutorial will help you to write up your homework. It will also help you to use Latex for other assignments than this course's homework.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Before we get started
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Make an account on overleaf.com and get started. No need to install anything.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Or if you want it the nerdy way...
% INSTALL LATEX: Before we can get started you need to install LaTeX on your computer.
				% Windows: http://miktex.org/download
				% Mac:         http://www.tug.org/mactex/mactex-download.html	
				% There a many more different LaTeX editors out there for both operating systems. I use TeXworks because it looks the same on Windows and Mac.
				

% SAVE THE FILE: The first thing you need to do is to save your LaTeX file in a directory as a .tex file. You will not be able to do anything else unless your file is saved. I suggest to save the .tex file in the same folder with your .R script and where you will save your plots from R to. Let's call this file template_homework1.tex and save it in your Week 1 folder.


% COMPILE THE FILE: After setting up your file, using your LaTeX editor (texmaker, texshop), you can compile your document using PDFLaTeX.
	% Compiling your file tells LaTeX to take the code you have written and create a pdf file
	% After compiling your file, in your directory will appear four new files, including a .pdf file. This is your output document.
	% It is good to compile your file regularly so that you can see how your code is translating into your document.
	
	
% ERRORS: If you get an error message, something is wrong in your code. Fix errors before they pile up!
	% As with error messages in R, google the exact error message if you have a question!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Now again for everyone...

% COMMANDS: 
	% To do anything in LaTeX, you must use commands
	% Commands tell LaTeX when to start your document, how you want your document to look, and how to format your document
	% Commands ALWAYS begin with a backslash \

% Everything following the % sign is a comment and will not be used by Latex to compile your document.
% This is very similar to # comments in R.

% Every .tex file usually consists of four parts.
% 1. Document Class
% 2. Packages
% 3. Header
% 4. Your Document

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 1. Document Class
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
 % The first command you will always have will declare your document class. This tells LaTeX what type of document you are creating (article, presentation, poster, etc). 
% \documentclass is the command
% in {} you specify the type of document
% in [] you define additional parameters
 
\documentclass[a4paper,12pt]{article} % This defines the style of your paper

% We usually use the article type. The additional parameters are the format of the paper you want to print it on and the standard font size. For us this is a4paper and 12pt.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 2. Packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Packages are libraries of commands that LaTeX can call when compiling the document. With the specialized commands you can customize the formatting of your document.
% If the packages we call are not installed yet, TeXworks will ask you to install the necessary packages while compiling.

% First, we usually want to set the margins of our document. For this we use the package geometry. We call the package with the \usepackage command. The package goes in the {}, the parameters again go into the [].
\usepackage[top = 2.5cm, bottom = 2.5cm, left = 2.5cm, right = 2.5cm]{geometry} 

% Unfortunately, LaTeX has a hard time interpreting German Umlaute. The following two lines and packages should help. If it doesn't work for you please let me know.
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

% use algorithm
\usepackage[linesnumbered,ruled,lined]{algorithm2e}

% use url
\usepackage{hyperref}

% The following two packages - multirow and booktabs - are needed to create nice looking tables.
\usepackage{multirow} % Multirow is for tables with multiple rows within one cell.
\usepackage{booktabs} % For even nicer tables.

% As we usually want to include some plots (.pdf files) we need a package for that.
\usepackage{graphicx} 

% The default setting of LaTeX is to indent new paragraphs. This is useful for articles. But not really nice for homework problem sets. The following command sets the indent to 0.
\usepackage{setspace}
\setlength{\parindent}{0in}

% Package to place figures where you want them.
\usepackage{float}

% The fancyhdr package let's us create nice headers.
\usepackage{fancyhdr}

% listings
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}


\lstdefinestyle{mypython}{
    backgroundcolor=\color{white},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\definecolor{codeblue}{rgb}{0.1,0.1,0.9}
\definecolor{backlightgrey}{rgb}{0.92,0.92,0.95}
\lstdefinestyle{mybash}{
    backgroundcolor=\color{white},   
    commentstyle=\color{codeblue},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    %numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 3. Header (and Footer)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% To make our document nice we want a header and number the pages in the footer.

% Options: fancy, plain, empty, fancyplain, fancyheadings, plainheadings, fancyplainheadings
\pagestyle{plain} % With this command we can customize the header style.

\fancyhf{} % This makes sure we do not have other information in our header or footer.

\lhead{\footnotesize Étude 03 Koch Snowflake Interactive}% \lhead puts text in the top left corner. \footnotesize sets our font to a smaller size.

%\rhead works just like \lhead (you can also use \chead)
\rhead{\footnotesize Riley Qian} %<---- Fill in your lastnames.

% Similar commands work for the footer (\lfoot, \cfoot and \rfoot).
% We want to put our page number in the center.
\cfoot{\footnotesize \thepage} 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 4. Your document
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Now, you need to tell LaTeX where your document starts. We do this with the \begin{document} command.
% Like brackets every \begin{} command needs a corresponding \end{} command. We come back to this later.

\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title section of the document
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% For the title section we want to reproduce the title section of the Problem Set and add your names.

\thispagestyle{empty} % This command disables the header on the first page. 

% \begin{tabular}{p{15.5cm}} % This is a simple tabular environment to align your text nicely 
% {\large \bf COSC326: Computational Problem Solving} \\
% The University of Otago \\ 
% Semester S1 2023  \\ 
% % Riley Qian\\
% \hline % \hline produces horizontal lines.
% \\
% \end{tabular} % Our tabular environment ends here.

\vspace*{0.3cm} % Now we want to add some vertical space in between the line and our title.

\begin{center} % Everything within the center environment is centered.
	{\Large \bf Étude 03 Koch Snowflake Interactive} % <---- Don't forget to put in the right number
	\vspace{2mm}
	
    % YOUR NAMES GO HERE
    Ruiyi Qian
	% data here
	% \today
	% {\bf Name 1 (xx\%), Name 2 (xx\%) (\& Name 3 (xx\%))} % <---- Fill in your names here!
		
\end{center}  

\vspace{0.4cm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Up until this point you only have to make minor changes for every week (Number of the homework). Your write up essentially starts here.

% Abstract here
\begin{abstract}
	% Abstract here
	
This is a task about drawing the Koch Snowflake. 
Koch Snowflake is a fractal curve, which is a curve that can never be drawn in a finite number of steps.
For most of the fractals, they are self-similar, which means that they can be divided into smaller parts that are similar to the whole.

In this project, I have implemented a program that can draw the Koch Snowflake interactively, and any order of the snowflake can be drawn in affordable time.

% TODO: change the link
You can find the source code of the program in \href{https://altitude.otago.ac.nz/rqian/cosc326-interactive-koch-snowflake.git}{\underline{this repository}}.

\end{abstract}

\section{Introduction} 

This task is to process the given dates and check whether they are valid or not. 

\begin{table}[h]
  \centering
  
  \begin{tabular}{|c|c|c|}
	\hline
	\textbf{Input (stdin)} & \textbf{Output (stdout)} & \textbf{Error Output (stderr)} \\
	\hline
	\texttt {4-6-92} & \texttt {04 Jun 1992} &  \\
	\texttt {04/06/92} & \texttt {04 Jun 1992} &  \\
	\texttt {3 AUG 97} & \texttt {03 Aug 1997} &  \\
	\texttt {12-Sep-1955} & \texttt {12 Sep 1955} &  \\
	\texttt {03 JUN 3004} & \texttt {03 JUN 3004 - INVALID} & \texttt {Year out of range} \\
	\hline
  \end{tabular}
\end{table}

The task input and output are shown in the table above. 
For the valid dates, the program will output the date in the format of 
day, month and year, which are separated by a space.
For the invalid, the program needs to identify the error and output the error message.
The valid date format is as follows consisting of day, month and year,
which are separated by a hyphen, slash or space. 
The exact rules are well defined in the task description. 
Such as the month can be written in digits or abbreviation, upper or lower case.
The year can be written in two or four digits.
The day can be written in one or two digits. 

\section{The Program}

Those rules can be summerized as grammer rules and range rules. 
Grammer rules are used to check the format of the date, quite easy and can be written in ANTLR4. 
Range rules are used to check the validity of the date, which is more complicated and needs to be checked in the program.
I will list the grammer rules and range rules in the following sections. 
And the detailed source code can be found in the repository.

\newpage

\subsection*{Grammer Rules}

\begin{lstlisting}[
        frame=trbl, basicstyle=\ttfamily
    ]
        grammar date;
        date:   day '-' month '-' year
            |   day '/' month '/' year
            |   day ' ' month ' ' year
            ;
        day:    DIGIT DIGIT | DIGIT;
        month:  DIGIT DIGIT | DIGIT 
            |   UPPER UPPER UPPER 
            |   UPPER LOWER LOWER 
            |   LOWER LOWER LOWER
            ;
        year:   DIGIT DIGIT DIGIT DIGIT | DIGIT DIGIT;
        DIGIT:  [0-9]
        UPPER:  [A-Z]
        LOWER:  [a-z]
\end{lstlisting}

\subsection*{Range Rules}

In this section, we assume that the date is valid in the grammer rules, 
and already converted to the format of day, month and year, 
note that the they are still in string format.
\\
So the first thing we need to do is to convert the string to integer. 
The following pseudo code shows what I have done.

\begin{algorithm}
	\caption{String to Integer}
	\SetAlgoLined
    \KwIn{raw day: $d_{str}$, raw month: $m_{str}$, raw year: $y_{str}$}
    \KwOut{day: $d$, month: $m$, year: $y$}
    \KwData{
    $M_{map} \gets \{
        \texttt{"JAN"}: 1, 
        \texttt{"FEB"}: 2, 
        \texttt{"MAR"}: 3, 
        \texttt{"APR"}: 4, 
        \texttt{"MAY"}: 5, 
        \texttt{"JUN"}: 6, 
        \texttt{"JUL"}: 7, 
        \texttt{"AUG"}: 8, 
        \texttt{"SEP"}: 9, 
        \texttt{"OCT"}: 10, 
        \texttt{"NOV"}: 11, 
        \texttt{"DEC"}: 12\}$ \\
    }
    \If {$m_{str}.{int()} \not \in \mathbf{N}$ } {
        \If {$m_{str}.{upper()} \not\in M_{map}.{keys()}$ } {
            \Return{{Invalid month}}  
        }
        $m_{str} \gets M_{map}.{get(}m_{str}.{upper())}.{str()}$ 
    }
    \If {$y_{str}.{length()}$ is 2} {
        \If {$y_{str}.{int()} < 50$} {
            $y_{str} \gets \texttt{"20"} + y_{str}$
        } \Else {
            $y_{str} \gets \texttt{"19"} + y_{str}$
        }
    }
    
    \Return{$d \gets d_{str}.{int()}$, $m \gets m_{str}.{int()}$, $y \gets y_{str}.{int()}$}
\end{algorithm}

\newpage

Then we can check the range rules. 
It is quite easy to check the year range, 
but the month and day range are more complicated. 
One thing to note is that the month and day range are different for leap year and non-leap year.
So it is better to check the leap year first.
I choose to use the following pseudo code to check the month and day range. 


\begin{algorithm}
    \caption{Check the range of the date}
	\SetAlgoLined
    \KwIn{day: $d$, month: $m$, year: $y$}
    \KwOut{valid date: $date$ or error message}
    $leap \gets [4 \mid y] \land (\neg [100 \mid y] \lor [400 \mid y])$ \\

    \lIf {$y \not \in [1753, 3000]$} {
        \Return{{Year out of range}}
    }
    \If {$m \in \{1, 3, 5, 7, 8, 10, 12\}$} {
        \lIf {$d \not \in [1, 31]$} {
            \Return{{Day out of range}}
        }
    } \ElseIf{$m \in \{4, 6, 9, 11\}$} {
        \lIf {$d \not \in [1, 30]$} {
            \Return{{Day out of range}}
        }
    } \ElseIf{$m \in \{2\}$} {
        \lIf {$d \not \in [1,  28 + leap]$} {
            \Return{{Day out of range}}
        }
    } \lElse {
        \Return{{Month out of range}}
    }
    \Return{$date\gets (d, m, y)$}

\end{algorithm}


\section{Data Generator}

The data generator is used to generate the test data for the program. 
And I have written a python script to generate the data. 
Just take it for granted, those date can be split into two groups,
one is the valid date, the other is the invalid date.
Considering the range of the year, the valid date is generated in the range of $[1753, 3000]$. 
So the valid date must be finite, and the invalid date is infinite. 
Finite data is easy to generate, but infinite data is hard to generate.
So let's focus on the valid date first.

\subsection*{Valid Date}

For convenience, I use the \texttt{<datetime>} module in python to generate the valid date. 

\begin{lstlisting}[language=Python, frame=trbl, basicstyle=\ttfamily, style=mypython]
import datetime    
begin_date = datetime.date(1753, 1, 1)
end_date = datetime.date(3000, 12, 31)
date = begin_date
while date <= end_date:
    # do something
    date += datetime.timedelta(days=1)
\end{lstlisting}

For each date, get the day, month and year from the \texttt{datetime} object, 
choose the format randomly, and then convert the date to string. 
Then we get the valid date that needs to be checked by the program. 
\\



\begin{lstlisting}[
    language=Python, frame=trbl, basicstyle=\ttfamily, style=mypython
]
separator_list = ['/', '-', ' ']       # separator list
day_list   = [str(d), str(d).zfill(2)] # day list
month_list = [str(m), str(m).zfill(2)] # month list
year_list  = [str(y), str(y)[-2:]]     # year list
m = abbr[m][0:3]
month_list.extend([m.upper(), m.lower(), m]) # month list
\end{lstlisting}

We first generate any valid variation of the date, 
organize them into a list, and then randomly choose one of them to generate the test data. 
Or just print them all out.

\begin{lstlisting}[
    language=Python, frame=trbl, basicstyle=\ttfamily, style=mypython
]
valid_list = []
for day in day_list:
    for month in month_list:
        for year in year_list:
            for sep in separator_list:
                date_string = day + sep + month + sep + year
                valid_list.append(date_string)
\end{lstlisting}

Now we have the valid date list, you can print them out or write them into a file. 

\begin{table}[h]
    \centering
    \caption{Valid Date \\ (The first 5 rows)}
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Input (stdin)} & \textbf{Output (stdout)} & \textbf{Error Output (stderr)} \\
        \hline
        \texttt {09-07-1766} & \texttt {09 Jul 1766} &  \\
        \texttt {7 jun 2153} & \texttt {07 Jun 2153} &  \\
        \texttt {02/jul/2319} & \texttt {02 Jul 2319} &  \\
        \texttt {09-Nov-2343} & \texttt {09 Nov 2343} &  \\
        \texttt {03/08/2387} & \texttt {03 Aug 2387} & \\
        \hline
    \end{tabular}
\end{table}
  

\subsection*{Invalid Date}

As I mentioned before, the invalid date is infinite, 
so we can not generate all of them.
My strategy is to generate the invalid date base on the valid date. 
Randomly choose a valid date, and then change one of its component to make it invalid.
For example, if the valid date is \texttt{29-07-1766}, we can

\begin{itemize}
    \item change the day to \texttt{32} to make it invalid
    \item change the month to \texttt{feb} to make it invalid
    \item change the year to \texttt{1752} to make it invalid
    \item change the separator to \texttt{'.'} to make it invalid
    \item delete one of the component to make it invalid
    \item insert some random character to make it invalid
    \item replace the whole date with some random string to make it invalid
    \item etc.
\end{itemize}

\newpage

Apart from this strategy mentioned above, 
I have tried about 12 tricks to generate the invalid date. 
These tricks are assigned with different weights, during the generation process, 
the program will randomly choose one of the tricks to generate the invalid date.


Now we have the invalid date list, you can print them out or write them into a file. 

\begin{table}[h]
    \centering
    \caption{Invalid Date \\ (The first 5 rows)}
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Input (stdin)} & \textbf{Output (stdout)} & \textbf{Error Output (stderr)} \\
        \hline
        \texttt {12-Apr-23.0} & \texttt {12-Apr-23.0 - INVALID} & \texttt {Invalid Year} \\
        \texttt {11/13/2125} & \texttt {11/13/2125 - INVALID} & \texttt {Month out of range} \\
        \texttt {not a date at all} & \texttt {not a date at all - INVALID} & \texttt {Invalid Grammer} \\
        \texttt {4-feb-?84?} & \texttt {4-feb-?84? - INVALID} & \texttt {Invalid Year} \\
        \texttt {32-12-3000} & \texttt {32-12-3000 - INVALID} & \texttt {Day out of range} \\
        \hline
    \end{tabular}
\end{table}

Those script can be found in the repository, \texttt{"src/gen/valid\_generator.py"} 
\\
and \texttt{"src/gen/invalid\_generator.py"}. 
\\
You can run them with the following command:

\begin{lstlisting}[language=bash,style=mybash, frame=trbl]
# generate 10 valid dates
## the generated dates are stored in the file "valid-10.in" 
## the expected output is stored in the file "valid-10.ans"
./scripts/generate.sh valid -n 10 -o valid-10 

# generate 10 invalid dates
## the generated dates are stored in the file "invalid-10.in"
## the expected output is stored in the file "invalid-10.ans"
./scripts/generate.sh invalid -n 10 -o invalid-10
\end{lstlisting}

\section{Local Judge}

This is an trial version of the local judge. 
I just implemented the basic functions, 
to make sure the program can run correctly,
and compare the spped of my implementation both in C++ and Python.
\\

It can works both on Linux and Mac OS. 
Make sure you have installed the \texttt{coreutils} in your system if you are using Mac OS.

\begin{lstlisting}[language=bash,style=mybash, frame=trbl]
 brew install coreutils
\end{lstlisting}

You can run the local judge with the following command:

\begin{lstlisting}[language=bash,style=mybash, frame=trbl]
# Test python version
./scripts/run_py.sh data/samples/
./scripts/run_py.sh data/generated/

# Test c++ version
./scripts/run_cpp.sh data/samples/
./scripts/run_cpp.sh data/generated/
\end{lstlisting}

\newpage

\section*{Appendix}

Here are 12 tricks I used to generate the invalid date.

\begin{enumerate}
    \item Totally not a date, e.g. \texttt{not a date at all}. 
        I add this trick to make sure the program can handle the invalid input. Even if the input is not a date,
        the program should still print out the error message.
    \item Manually edge case, e.g. \texttt{32-12-3000}. These case are hard to be covered by the random generation.
    \item Randomly edge case. I randomly choose a valid date, and then change one of its component to make it invalid.
        For example, if the valid date is \texttt{29-07-1766}, we can change the day to \texttt{32} to make it invalid.
    \item Totally random string. In the visible ASCII range, I randomly generate a string with length between 1 and 20.
        I assume that the string is not a valid date. But it is possible that the string is a valid date, just ignore it.
    \item Valid date with valid but different seperator. I randomly choose a valid date, and then change the one of the separators to 
        \texttt{'/'}, \texttt{'-'} or \texttt{' '}, which is different from the original separator. 
        The generated date will be like \texttt{29-07 1766} or \texttt{29-07/1766}.
    \item Valid date with invalid seperator. I randomly choose a valid date, and then change the one of the separators to 
        \texttt{'.'}, \texttt{'\textbackslash'}, \texttt{'\textasciicircum'}, \texttt{'\textasciitilde'}, \texttt{'\textasciigrave'}, 
        \texttt{'\textasciicircum'}, \texttt{'\textasciitilde'}, \texttt{'\textasciigrave'}, \texttt{'\textasciicircum'}, 
        \texttt{'\textasciitilde'}, \texttt{'\textasciigrave'}, \texttt{'\textasciicircum'}, \texttt{'\textasciitilde'}, 
        \texttt{'\textasciigrave'}, \texttt{'\textasciicircum'}, \texttt{'\textasciitilde'}, \texttt{'\textasciigrave'}, 
        \texttt{'\textasciicircum'}, \texttt{'\textasciitilde'}, \texttt{'\textasciigrave'}, \texttt{'\textasciicircum'}, 
        \texttt{'\textasciitilde'}, \texttt{'\textasciigrave'}, \texttt{'\textasciicircum'}, \texttt{'\textasciitilde'}, 
        \texttt{'\textasciigrave'}, \texttt{'\textasciicircum'}, \texttt{'\textasciitilde'}, \texttt{'\textasciigrave'}, 
        \texttt{'\textasciicircum'}, \texttt{'\textasciitilde'}, \texttt{'\textasciigrave'}, \texttt{'\textasciicircum'}, 
        \texttt{'\textasciitilde'}, \texttt{'\textasciigrave'}, \texttt{'\textasciicircum'}, \texttt{'\textasciitilde'}, 
        \texttt{'\textasciigrave'}, \texttt{'\textasciicircum'}, \texttt{'\textasciitilde'}, \texttt{'\textasciigrave'},
    \item Randomly insert a non digit character. I randomly choose a valid date, and then insert a non digit character to the date.
        For example, if the valid date is \texttt{29-07-1766}, we can insert a non digit character to the date to make it invalid.
        The generated date will be like \texttt{29-07-1766?} or \texttt{29-07?-1766}.
    \item Ramdomly replace a character in day with a non digit character. I randomly choose a valid date, and then replace a character in the day with a non digit character.
        For example, if the valid date is \texttt{29-07-1766}, we can replace the first character in the day to make it invalid.
        The generated date will be like \texttt{2\#-07-1766} or \texttt{\&9-07-1766}.
    \item Ramdomly replace a character in year with a non digit character. I randomly choose a valid date, and then replace a character in the year with a non digit character.
        For example, if the valid date is \texttt{29-07-1766}, we can replace the first character in the year to make it invalid.
        The generated date will be like \texttt{29-07-1\&66} or \texttt{29-07-\#766}.
    \item For month represented by digits, replace a charactor with non digit character like what we have done in day and year.
        For month represented by string, randomly make one of the character upper case or lower case, stop if the month is valid.
    \item Duplicate a valid date. I randomly choose a valid date, and then duplicate it to make it invalid.
        For example, if the valid date is \texttt{29-07-1766}, we can duplicate it to make it invalid.
        The generated date will be like \texttt{29-07-1766 29-07-1766}. This can be used to test the program can handle the next line.
    \item Leap year \texttt{29 02 ????}. Ramdomly generate a leap year, and then append \texttt{29 02} to the year.
    
\end{enumerate}

% - [COSC 326 - Etude 01 - Dates](docs/etude01-dates.pdf)
% - [How To Calculate Leap Years](https://www.wikihow.com/Calculate-Leap-Years)
% - [Parsing Dates in Python](https://realpython.com/python-datetime/)
% - [Parse Tree](https://en.wikipedia.org/wiki/Parse_tree)

% How to convert those reference to bibtex?

\begin{thebibliography}{10}
\bibitem{etude01-dates}
COSC 326.
\newblock Etude 01 - Dates.
\newblock {\em https://www.cs.otago.ac.nz/cosc326/2022/etudes/etude01-dates.pdf}.

\bibitem{wikihow-leap-years}
Wikihow.
\newblock How To Calculate Leap Years.
\newblock {\em https://www.wikihow.com/Calculate-Leap-Years}.

\bibitem{python-datetime}
Real Python.
\newblock Parsing Dates in Python.
\newblock {\em https://realpython.com/python-datetime/}.

\bibitem{parse-tree}
Wikipedia.
\newblock Parse Tree.
\newblock {\em https://en.wikipedia.org/wiki/Parse\_tree}.

\end{thebibliography}

\end{document}
